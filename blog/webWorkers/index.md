# 工作者线程
  允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。

  JavaScript 环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。

  使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境不能与依赖单线程交互的API（如DOM）互操作，但可以与父环境并行执行代码。

## 工作者线程与线程（执行线程）区别
### 共同点：
  - 工作者线程是以实际线程实现的
  - 工作者线程并行执行。每个环境中的指令可以并行执行
  - 工作者线程可以共享某些内存。工作者线程可以使用 SharedArrayBuffer 在多个环境间共享内容。
### 区别：
  - 工作者线程不共享全部内存。在传统线程模型中，多线程有能力读写共享内存空间。除了 SharedArrayBuffer 外，从工作者线程进出的出具需要复制或者转移。
  - 工作者线程不一定在同一个进程里。通常，一个进程内部可以产生多个线程。**根据浏览器引擎的视线，工作者县城可以能页面属于同一个进程，也可能不属于。**例如，Chrome 的 Blink 引擎对共享工作者线程和服务工作者线程使用独立的进程。
  - 创建工作者线程的开销更大。工作者线程有自己独立的事件循环、全局环境、事件处理程序 和其他 JavaScript 环境必需的特性。创建这些结构的代价不容忽视。

  工作者线程相对比较重，不建议大量使用。

## 工作者线程
### 工作者线程类型
  - 专用工作者线程

    是一种实用的工具，可以让脚本单独创建一个 JavaScript 线程，以执行委托的任务。**只能被创建它的页面使用**

  - 共享工作者线程

    和专用工作者线程相似。主要却别是共享工作者线程可以被多个不同的上下文使用，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或者从中接收消息。

  - 服务工作者线程

    和专用工作者线程，共享工作者线程完全不一样。主要用途是拦截、重定向和修改页面发出的请求，充当网络请求仲裁者的角色。

### 工作者线程全局对象
  在工作者线程中，全局对象是 WorkerGlobalScope 的实例，通过 self 关键字暴露出来。

  self 上可用的属性和方法是 window 对象上属性的严格自己。

#### 属性
  - navigator
  - self
  - location
  - performance
  - console
  - caches
  - indexedDB
  - isSecureContext
  - origin

#### 方法
  - atob()
  - btoa()
  - clearInterval()

#### 子类
  不是所有的地方都实现了 WorkerGlobalScope。每种类型的工作者线程都使用了自己特定的全局对象，这继承自 WorkerGlobalScope。
  * 专用工作者线程：DedicatedWorkerGlobalScope
  * 共享工作者线程：SharedWorkerGlobalScope
  * 服务工作者线程：ServiceWorkerGlobalScope

## 专用工作者线程
  网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。这样的线程可以与父页面交换信息、发送网络请求、执行文件的输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面线程里做的任务。
### 概念
  可以把专用工作者线程称为后台脚本（background script）。**JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入/输出，都由初始化线程时提供的脚本来控制。**该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始。 

### 特性
  - 工作者线程的脚本文件只能从与父页面相同的源加载。从其他的源加载会报错。
  - 基于加载脚本创建的工作者线程不受文档的内容安全策略限制，因为工作者线程在与父文档不同的上下文中运行。

### 应用场景
  - 加载js文件

### 使用
#### 创建
  ```js
    // 用 worker 加载js文件
    const worker = new Worker('./emptyWorker.js');
  ```
#### Worker对象支持的事件处理程序
  - onerror
  - onmessage
  - onmessageerror
  - postMessage(): 用于通过异步消息事件向工作者线程发送消息
  - terminate(): 用于立即终止工作者线程。一旦调用了terminate(),工作者线程的消息队列就会被清理并锁住。

#### DedicatedWorkerGlobalScope 增加的属性和方法
  - name: 给 Worker 构造函数提供一个可选的字符串标识
  - postMessage(): 与 worker.postMessage()对应的方法，用于从工作者线程内部向父上下文发送消息
  - close(): 与 worker.terminate()对应的方法，用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。
    
    **close()会通知工作者线程取消时间循环中的所有任务，并阻止继续添加新任务。**

    **工作者线程不需要执行同步停止**

  - importScripts(): 用于向工作者线程中导入任意数量的脚本。

    **该方法可用于全局 Worker 对象。这个方法会加载脚本并按照加载顺序同步执行。**

    **脚本加载会收到常规 CORS 的限制，但在工作者线程内部可以请求来自任何源的脚本。**这里的脚本导入类似于```<script>```标签动态加载脚本。在这种情况下，所有导入的脚本也会共享作用域。

#### 与专用工作者线程通信
  - postMessage()
  - MessageChannel 

    MessageChannel 实例有两个端口，分别代表两个通信端点。

  - BroadcastChannel

    同源脚本能够通过 BroadcastChannel 相互之间发送和接收消息。

#### 工作者线程数据传输
  使用工作者线程时，经常需要为它们提供某种形式的数据负载。工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。

  **在javascript中，有三种在上下文间转移信息的方式：结构化克隆算法（structured clone algorithm）、可转移对象（transferable objects）和共享数组缓冲区（shared array buffers）**

  - 结构化克隆算法：用于两个独立上下文间共享数据。
  - 可转移对象：可以把所有权从一个上下文转移到另一个上下文。比如：ArrayBuffer，MessagePort，ImageBitmap，OffscreenCanvas
  - 共享数组缓冲区：既不克隆，也不转移，SharedArrayBuffer 作为 ArrayBuffer 能够在不同的浏览器上下文间共享。

## 共享工作者线程
  共享工作者线程可以被多个可信任的执行上下文访问。例如：同源的两个标签页可以访问同一个共享工作者线程。

  **共享工作者线程适合希望通过在多个上下文中共享线程减少计算性消耗的情形。**

## 服务工作者线程
  服务工作者线程是一种类似浏览器中代理服务器的线程，可以拦截外出请求和缓存响应。
  
  这可以让网页再没有网络连接的情况下正常使用，因为部分或者全部页面可以从服务工作线程缓存中提供服务。

  服务工作者线程也可以使用 Notifications API、Push API、Background Sync API 和 Channel Messaging API.

  来自一个域的多个页面共享一个服务工作者线程。

  对于大多数开发者而言，服务工作者线程在两个主要任务上最有用：充当网络请求的缓存层和启用推送通知。

## 小结：
  工作者线程可以运行异步 JavaScript 而不阻塞用户界面。这非常适合复杂计算和数据处理，特别是需要花较长时间因而会影响用户使用网页的处理任务。工作者线程有自己独立的环境，只能通过异步消息与外界通信。

  工作者线程可以是专用线程、共享线程。专用线程只能由一个页面使用，而共享线程则可以由同源的任意页面共享。

  服务工作者线程用于让网页模拟原生应用程序。服务工作者线程也是一种工作者线程，但它们更像是网络代理，而非独立的浏览器线程。可以把它们看成是高度定制化的网络缓存，它们也可以在 PWA 中支持推送通知