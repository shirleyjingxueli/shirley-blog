# js-浏览器-渲染
  相关资料：https://time.geekbang.org/column/article/116572
## 渲染流程
### 构建 DOM 树
  因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 - DOM 树

### 样式计算
  步骤：
  1. 把 CSS 转换为浏览器可以理解的结构（通过link引入的、style标签内部的、元素的 style 属性内嵌的css）。可以通过 ```document.styleSheets```来查看其结构。
  2. 转换样式表中的属性值，使其标准化（比如em会被转换为px，color值会被转换为rgb值，bold会被转换为700）
  3. 计算 DOM 树中每个节点的具体样式（可以通过开发者工具样式中的Computed子标签来查看）
    
    涉及到 CSS 样式继承以及层叠规则。

### 布局阶段
  计算出 DOM 树中可见元素的几何位置。

  步骤：
  1. 创建布局树：遍历 DOM 树中的所有可见节点，构建一个只包含可见元素的布局树
  2. 布局计算：计算布局树节点的坐标位置。

### 分层
  由于页面中会有很多复杂的效果，比如一些复杂的 3D 转换，页面滚动，或者使用z-index 做 Z 轴排序等，为了方便实现这些效果，**渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树。**

  可以通过开发者工具的 Layers 标签，看到页面的分层情况。

  **浏览器的页面实际上被分层了很多图层，这些图层叠加后合成了最终的页面。**

  **并不是布局树中的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就会从属于父节点的图层。**

  #### 哪些节点会创建新的图层
  满足以下两点中的任意一点就会被提升为一个图层
  - 用用层叠上下文属性的元素会被单独提升为一个图层

   [参考链接](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)

  - 需要剪裁（clip）的地方会被创建为图层。

    比如div大小为200*200,而div内部文字内容比较多，文字内容超出显示区域，这个时候就产生了剪裁。**渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。**

### 绘制
  对图层进行绘制

  渲染引擎会把一个图层的绘制，拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。**在图层阶段，输出的就是这些待绘制列表。**

  可以通过开发者工具Layers标签，选择 document层，来实际体验绘制列表。

  ![Alt text](paint.png)

### 分块、光栅化、合成
绘制列表只能用来记录绘制顺序和绘制指令的列表，而实际绘制操作是由渲染引擎中的合成线程来完成的。

  渲染主线程和合成线程之间的关系：
  
  1. 当图层的绘制列表准备好之后，主线程会把绘制列表提交给合成线程。

  ![Alt text](raster.png)

  2. **合成线程会将图层划分为图块，这些图块通常会是256*256 或者 512*512**

  3. 合成线程会按照视口附近的图块优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓的栅格化是将图块转换为位图。
  
  4. 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令--“DrawQuad”，然后将该命令提交给浏览器进程。

  5. 浏览器进程里面一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，让后根据 DrawQuad命令，将页面内容绘制在内存中，最后通过内存显示在屏幕上。

#### 分块
  将图层进行分块
#### 光栅化
  将图块转换为位图。图块是栅格化执行的最小单位。

  渲染进程维护了一个栅格化的线程池，所有的图块的栅格化都是在线程池中完成的。

  ![Alt text](rasterLine.png)

  栅格化会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图保存在 GPU 内存中。

  如果 栅格化使用了 GPU, 那么最终生成的位图是在 GPU 中完成的，这就涉及到了跨进程操作。渲染进程将生成图块的指令发送给 GPU， 然后在 GPU 中生成图块的位图，并且保存在 GPU 中。

  ![Alt text](gpuRaster.png)

#### 合成
  等待所有图块光栅化，生成绘制图块指令，将页面内容绘制到内存中，最后再将内存显示在屏幕上。

## 渲染流程图
  ![Alt text](renderAll.png)