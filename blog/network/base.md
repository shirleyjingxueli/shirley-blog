#  HTTP -基础
### 打开一个网页发生了什么？
  - ** DNS 解析**

  - ** TCP 连接**

  - ** IP 远程定位**

  - **mac地址两点传输**

  - **网卡(出口)：**将数字信息转换为电信号，在网线上传输

    * 将数据复制到网卡的缓存区域，在其开头添加报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列

  - **交换机：**

    * 交换机的mac地址包含：设备的mac地址；设备连接在交换机的哪个端口上

    * 如果找不到mac地址，除了源端口以外的所有端口都会被发送一次

  - **路由器：**

    * 数据经过路由器的层层转发，最终到达目的地（目标服务器）

  - **服务器：**
  
    * 数据到达服务器之后，会开始去除头部信息，进行一层层传输

###  DNS 解析
  - ** DNS ：**
    * 根域名服务器(.)

      1. 根域名中的服务器信息保存在互联网中的所有 DNS 服务器中
  
    * 顶级域名服务器(.com) --- com,cn

    * 权威域名服务器(server.com) --- goole.cn, server.com
    
  - **域名解析的流程**
    * 客户端发送 DNS 请求查询 IP ，并发送给本地 DNS 服务器

    * 本地 DNS 服务器有缓存就可以直接返回，没有的时候请求根域名服务器

    * 根域名服务器根据后缀，发送顶级域名服务器地址给客户端

    * 客户端向根域名服务器查询权威域名服务器地址

    * 权威域名服务器返回 IP 地址给到客户端

  - **域名解析每次都是这个流程吗？**
    * 不是的

    * 查看的顺序：
    
      浏览器缓存 --- 操作系统缓存 --- hosts文件; 如果都没有才会发送给本地 DNS 服务器去查找，走域名解析流程，如果其中有一个有的话，就会直接返回

  - **作用：**
  
  查询 IP ；做负载均衡

   DNS 也可以做负载均衡

   DNS 分地址和运营商都是为了返回最优 IP 返回离用户最近的 IP ，提高用户的访问速度

###  TCP 
  - 查看 TCP 连接状态：netstat -napt

  - 建立连接和断开连接

   * 三次握手：保证双方都有发送和接收的能力

   * 四次挥手：

  - 分割数据：数据以mss的长度进行分割

    * MTU: 一个网络包的最大长度

    * MSS: 除去 IP 和 TCP 头部以后，一个网络包所能容纳的最大的 TCP 数据的最大长度

  -  TCP  模块在执行连接、接收、断开等各个阶段的操作，都需要 IP 模块把数据封装成网络包发送给通信对象

### 安全和幂等（get请求是安全和幂等的，post请求不是安全的，也不是幂等的）

  * 在  HTTP  协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。

  * 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

###  HTTP 状态码

 - 1xx: 提示信息

 - 2xx：请求成功

  * 204 没有内容，响应头没有body数据

  * 206 分块下载或者断点续传，只有部分内容，但是服务器处理成功的状态

 - 3xx：重定向

  * 301 永久重定向，资源已经不存在了，需要用新的url重新访问

    a. 网站的url结构发生变化，资源被转移到新的位置时

    b. 请求旧地址，返回301状态码以及新的url
    
    c. 客户端自动重定向到新的url（原始请求方法会变为GET方法）

    d. 请求方法的变更是为了确保重定向后的请求不会修改或者删除任何资源，以遵守 HTTP 的安全性和幂等性

  * 302：临时重定向，请求的资源还在，需要临时用另一个url来访问

    a. 服务器收到请求，返回302和新的url

    b. 客户端自动将请求重定向到新的url，但会将请求方法（GET、POST）保持不变

 - 4xx：客户端错误

 - 5xx：服务器错误

### 粘包
  - **概念：**
  
    多个数据被连续发送给接收方，形成一个大的数据块。可能导致接收方无法正确解析和处理接收到的数据

  - **经常出现在面向流的传输过程（如 TCP ）**

  - **出现原因：**

    * 网络延迟

    * 缓冲区大小限制

    * 持续发送多个数据等、

  - **解决办法：**

    * 定长包

    * 包头 + 包体

    * 分隔符  

###  HTTP  头

  - **请求头**

    * connection

    * accept

    * accept-encoding

    * withCredential

  - **响应头**

    * content-length

    * content-type

    * conent-encoding

    * access-control-allow-origin

    * access-control-allow-method

    * access-control-allow-credential

###  TCP  keep-alive 和  HTTP  keep-alive

  - **概念和特性**
  * TCP ：在长时间没有数据传输的情况下检测和维持  TCP  的活跃性

    a 定时发送：定时发送报文到对端，检测连接的活跃性

    b 可配置性：根据操作系统进行配置调整，包括间隔时间、重试次数、超时时间等。

    c 不同操作系统对 keepAlive 的支持和行为会有所不同

    d 默认不是开启的

  * HTTP ：允许在单个  TCP  连接上发送和接收多个 HTTP 请求和响应，启用 keep-alive，并且在一段时间内没有请求或者响应时，keep-alive 的有效期会过期

  - **两者的区别：**

    * 层级不同： HTTP 是应用层， TCP 是传输层

    * 目的不同： HTTP 是发送和接收多个请求，提高性能，减少连接开销； TCP  是检测和维持 TCP 连接的活跃性

    * 触发方式不同： HTTP 通过请求头， TCP 是在操作系统内核层面实现的，由操作系统自动发送特殊的 KeepAlive 报文检测

    * 配置不同： HTTP 在应用层进行配置; TCP 可以调整操作系统中的相关配置来实现

###  HTTP 的缓存技术

  - **强制缓存**

    * 概念：判断浏览器缓存有没有过期，决定是否使用缓存的主动权在浏览器

    * 表现: status Code: 200 (from disk cache)

    * 涉及到的请求头:(cache-control的优先级高于expires)

      a. cache-control

      b. expires

    * 具体流程：

      a. 客户端发送请求  

      b. 服务器返回资源，response头部设置cache-control

      c. 浏览器再次发送请求，会比较发送请求时间和cache-control中的过期时间，判断是否过期，未过期则使用缓存，否则重新发起请求

      d. 强制缓存在未过期的情况下，不会向服务端发起请求

      e. 过期的情况下，服务端收到重新发送的请求，会再次更新response头部的cache-control

  - **协商缓存**

    * 涉及到的头部

      * if-modified-since; last-modified (基于时间来实现的)

      * if-none-match; etag;（基于唯一标识符来实现的）

      * etag 的优先级比 last-modified 高

    * 为什么 etag 优先级高

      a. 在没有修改文件内容的情况下，文件的最后修改时间也可能发生变化，会导致客户端重新请求

      b. 有些文件的修改是在秒级以内发生的，但是 if-modified-since 能检查到的颗粒度是秒级的，这种情况下etag能保证客户端在一秒内刷新多次 

      c. 有些服务器不能精准确定文件的最后修改时间

    * 具体流程：

      a. 第一次请求，在本地缓存资源

      b. 第二次访问，头部携带last-modified 或者 etag，服务端如果返回304，则使用本地缓存

    * 协商缓存都需要配合强制缓存cache-control来使用

    只有在强制缓存校验过后，才可以进行协商缓存  

###  TCP 和 UDP 的区别

  面向连接指的是客户端和服务端为了维护连接而建立的数据结构，正是这样的数据结构来维护双方的连接状态

  -  TCP 是可靠交付（无差错，不丢失，不重复，有顺序）, UDP 是无序的，并且是不保证数据完整性的

  -  TCP 是面向字节流， UDP 是基于数据报文的，会一个个的发，一个个的收

  -  TCP 是有拥塞机制的，在网络不好的情况下，会控制发送速度，但是 UDP 是不会的

  -  TCP 是有状态的，会记录发送的状态等，但是 UDP 是不会的

  ** IP 层上会有一个8位头，用来区分是 TCP 还是 UDP ，根据端口号将数据发送给目标程序**

###  UDP 的应用场景

  - 需要网络好，或者是对丢包不敏感的程序

  - 不需要一对一沟通，建立链接，可以广播的应用

  - 需要处理速度快，时延低，可以容忍少数丢包，即使在拥塞的情况下，也能将包发过去

###  UDP 具体使用场景

  - 网站或者app访问

  - 媒体流
  
  - 实时游戏

  - 物联网

  - 移动通信领域

###  TCP 包头（连接状态控制、顺序问题、丢包问题、流量控制、拥塞控制）

  - 端口号：目标端口号、源端口号

  - 包序列号

  - 状态位：syn:发送一个链接 ack：回复 rst：重新建立连接 fin：结束连接  

  - 窗口大小：流量控制

###  TCP 三次握手原因：

  - 建立连接

  - 包的序号问题（双方会互相告诉包的开始序号）

  wait时间2msl，最大报文生存时间

###  TCP 怎么确保包的顺序以及完整性

  - 每一个包都有一个id，都必须要有应答（ack）

  - 累计应答

### 发送端和接收端状态

  - 发送端

    * 已发送已确认

    * 已发送未确认

    * 未发送可发送
    
    * 未发送不可发送

  - 接收端

    * 已接收已确认

    * 已接收未确认

    * 不能接收

###  TCP 如何解决包丢失以及顺序问题

  - 超时重试，每超时一次，重试时间*2

  - 快速重传，当接收包的序号>期望接收包的序号时，进行冗余ack，来告知发送端需要重传

  - sack，在 TCP 头部添加sack，通过发送缓存地图告诉发送端数据丢失

###  TCP 如何进行流量控制

  - 控制窗口大小  

###  TCP 如何解决通道拥塞问题

  也是通过控制窗口大小来决定的，具体方法如下：  TCP  BBR算法    

### BBR如何解决延时问题

  - S1：慢启动开始时，以前期的延迟时间为延迟最小值Tmin。然后监控延迟值是否达到Tmin的n倍，达到这个阀值后，判断带宽已经消耗尽且使用了一定的缓存，进入排空阶段。

  - S2：指数降低发送速率，直至延迟不再降低。这个过程的原理同S1

  - S3：协议进入稳定运行状态。交替探测带宽和延迟，且大多数时间下都处于带宽探测阶段。

### SOCKET

  - socket 是端到端的通信

  -  TCP 是数据流，设置为 socket_stream;  UDP 是数据报，设置为 socket_dgram

  - 监听用的 socket 和真正用来传递数据的是两个，一个叫做监听 socket，一个叫做已连接 socket

### socket_ TCP 流程

  - 服务端监听一个端口，给 socket 赋予一个 IP 和端口

  - 调用 listen 函数进行监听

  - 在内核中建立两个连接，一个是 TCP 三次握手建立的已经处于 established 的连接，一个是没有完全建立的队列 sync_rcvd

  - 服务端调用 accept 函数，取出一个已经建立好的连接开始处理

  - 在服务端等待的过程中，客户端通过 connect 建立连接。先在参数中指明要连接的  IP  地址和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket

  - 建立好连接之后，双方就可以 read 和 write   

### socket_ UDP 流程

  -  UDP  是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect，但是， UDP  的交互仍然需要  IP  和端口号，因而也需要 bind。 

  -  UDP  是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入  IP  地址和端口。  
    